# Boolean-based SQL Injection

> [!WARNING]
> **Ethics reminder:** Boolean-based (content-based) blind SQLi is a powerful technique that can extract data slowly and noisily. Use it **only** in authorized testing environments (local labs, intentionally vulnerable apps, or with explicit written permission). Do not test systems you do not own.

---

## What is Boolean-based SQL Injection?

Boolean-based SQLi (a subset of blind SQLi) relies on observing differences in an application's response when a SQL condition evaluates to `TRUE` versus `FALSE`. The application does not return query results directly, but its behavior (content, status, or structure) changes in measurable ways.

Because the responses are often subtle, detection and extraction require careful comparison and automation.

---

## Basic idea & quick checks

1. **Confirm influence** with simple true/false payloads:

   * `AND 1=1` (TRUE)
   * `AND 1=2` (FALSE)

2. **Observe** differences in response body, length, headers, or status codes.

**Example:**

```
GET /product?id=10' AND 1=1 --
GET /product?id=10' AND 1=2 --
```

If the first returns product details and the second returns a generic page (or no details), the input likely affects SQL conditions.

---

## Character extraction strategy (high level)

To extract values (like username, DB version) character-by-character:

1. Choose a target expression, e.g., `(SELECT user())` or `(SELECT database())`.
2. For position `i` and candidate character `c`, send a payload that tests whether the `i`th character equals `c`.

**Payload pattern (MySQL-style):**

```sql
' AND SUBSTRING((SELECT user()), i, 1) = 'c' --
```

Repeat `c` over a character set (e.g., `abcdefghijklmnopqrstuvwxyz0123456789@_-.`) and iterate `i` from 1..N until you reconstruct the full value.

**Optimizations:**

* Use binary search over ASCII ranges to reduce requests.
* Prioritize common characters (letters, digits, `@`, `_`, `-`, `.`) to speed extraction.
* Parallelize tests carefully and within allowed rate limits.

---

## DBMS-specific examples

**MySQL (character test):**

```sql
' AND SUBSTRING((SELECT database()),1,1) = 'd' --
```

**Postgres (character test):**

```sql
' AND SUBSTRING((SELECT current_database()),1,1) = 'd' --
```

**MSSQL (character test):**

```sql
' AND SUBSTRING((SELECT SYSTEM_USER),1,1) = 'd' --
```

Adjust functions and syntax per DBMS — consult `examples/` for DB-specific payloads.

---

## Measuring differences reliably

* **Baseline:** Capture a reference response before sending tests.
* **Length diff:** Compare byte-lengths of responses (fast and simple).
* **DOM diff:** Use a DOM/diffing tool to spot missing elements or structural changes.
* **Status/headers:** Sometimes the app returns different status codes or headers.
* **Repeat & average:** Re-run tests to avoid false positives from network noise or transient server behavior.

---

## Defensive guidance

* **Parameterize** all queries — eliminates injection from the start.
* **Normalize responses** — return consistent page structures for different internal conditions when feasible.
* **Monitor for probing patterns** — many similar requests differing only by small payloads are suspicious.
* **Rate-limit sensitive endpoints** to make large-scale extraction impractical.
* **Restrict DB functions** and privileges to reduce what can be extracted.

---

## Tooling & automation (authorized use only)

* **Burp Suite Intruder/Repeater** — craft payload lists and compare responses.
* **Custom scripts** — Python with `requests` or `httpx` for precise control and automation.
* **sqlmap** — supports boolean-based blind extraction (`--technique=B`), but it is noisy; use only with permission.

---

## Practical tips for testers

> [!TIP]
> * Keep a tight log of requests and findings.
> * Start extracting short, high-value fields (DB user, DB name) to confirm technique before attempting long dumps.
> * Respect rate limits and avoid excessive parallelism in production environments.