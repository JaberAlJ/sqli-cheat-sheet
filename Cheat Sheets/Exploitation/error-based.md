# Error-based SQL Injection

> [!WARNING]
> **Ethics reminder:** The content below is for education and authorized testing only. Error-based SQLi leverages database error messages to extract information. Do **not** use these techniques against systems you do not own or for which you do not have explicit written permission.

---

## What is Error-based SQL Injection?

Error-based SQLi forces the database to return detailed error messages that contain sensitive information — such as table/column names, SQL fragments, or DBMS version details — which an attacker can use to craft further attacks.

This technique relies heavily on applications that reveal database errors directly to users. Modern production apps should not display raw DB errors.

---

## How it works (high-level)

1. An attacker injects input that causes the database to execute an expression which raises an error containing data of interest.
2. The application displays the error, revealing the embedded information.
3. The attacker adapts subsequent payloads to extract more data.

Because error messages vary by DBMS and configuration, payloads must be tailored to the target.

---

## Common patterns & illustrative payloads

Below are illustrative patterns (non-exhaustive). Exact syntax and functions differ by DBMS.

### 1. Forcing a string concatenation error (MySQL/Postgres variants)

* Idea: Use functions that create long strings or invalid conversions inside an expression that causes an error.
* Simple trigger: send a single quote `'` or malformed input to provoke a syntax error.

### 2. Using `CAST`/`CONVERT` to expose data

* Convert strings to numeric types intentionally to cause conversion errors revealing content.
* Example pattern (illustrative):

```sql
' AND 1=(SELECT CAST((SELECT database()) AS INT)) --
```

This will likely error because the database name is not an integer; the error message may show the string being converted.

### 3. Using duplicate-key or grouping errors to leak data

* Construct subqueries with `CONCAT()` in MySQL inside aggregate/group operations to force an error containing the concatenated data.
* Example pattern (MySQL):

```sql
' AND (SELECT 1 FROM (SELECT COUNT(*), CONCAT((SELECT database()), FLOOR(RAND(0)*2)) x FROM information_schema.tables GROUP BY x) t) --
```

This pattern attempts to generate a non-unique grouping value that can cause an error including the concatenated piece.

### 4. Deliberate division by zero (less informative but sometimes used)

* `... AND 1/(SELECT CASE WHEN (condition) THEN 0 ELSE 1 END) = 1 --`
  This can generate an error message that sometimes includes context but is less commonly informative than string-based errors.

**Note:** These payloads are illustrative. Many modern DBMS configurations will not leak useful information in errors, and web frameworks may sanitize error output.

---

## DBMS-specific notes and common error signals

* **MySQL:** `You have an error in your SQL syntax...`, `Truncated incorrect DOUBLE value` — may reveal actual input parts.
* **Postgres:** `ERROR: invalid input syntax for integer: "..."`, `operator does not exist` — can help identify type mismatches and content.
* **MSSQL:** `Conversion failed when converting the varchar value '...' to data type int.` — sometimes reveals the value being converted.
* **Oracle:** `ORA-01722: invalid number` or `quoted string not properly terminated` can reveal fragments.

---

## Detection methodology (authorized)

1. Trigger harmless syntax errors using single quotes, unclosed parentheses, or comment markers.
2. Observe responses for DB-specific error patterns (see `detection/error-messages.md`).
3. If errors are shown, craft targeted payloads to cause errors that contain selected data (e.g., table names).
4. Always minimize noise and frequency of requests to remain within legal/ethical bounds.

---

## Example investigative workflow (lab-only)

1. Start with a simple probe: `id=1'` — look for any error text returned.
2. If errors appear, try to fingerprint DBMS using known error phrases.
3. Use tailored payloads to extract specific metadata (e.g., `information_schema` names), preferably one item at a time to avoid noisy queries.
4. Document everything and stop if the target shows defensive measures (WAF blocks, admin alerts).

---

## Defensive guidance

* **Never return raw DB errors to users.** Replace with generic messages and log details internally.
* **Use parameterized queries** to prevent arbitrary expressions from executing.
* **Sanitize and validate inputs** so unexpected types cannot reach the DB layer.
* **Harden DB configuration** to avoid verbose or revealing error outputs.
* **Apply least privilege** to reduce what an attacker can discover even if they trigger errors.

---

## Tooling (authorized & cautious use)

* **Burp Suite** — intercept and edit requests to quickly test error responses.
* **sqlmap** — can attempt error-based techniques; use with explicit permission and in controlled settings.

---

## Final notes

> [!NOTE]
> Error-based SQLi can be very effective when verbose errors are returned, but modern best practices and production setups reduce this surface significantly. When present, error-based findings should be treated seriously and remediated promptly.