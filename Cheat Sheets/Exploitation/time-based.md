# Time-based SQL Injection

> [!WARNING]
> **Ethics reminder:** Time-based blind SQLi relies on inducing deliberate delays in the database to infer information. This is slow and noisy — use it **only** in authorized testing environments (local labs, intentionally vulnerable apps, or with explicit written permission). Do not test systems you do not own.

---

## What is Time-based SQL Injection?

Time-based SQLi is a blind technique where the attacker causes the database to pause (sleep) when a tested condition is true. By measuring the application's response time, the attacker infers whether the condition evaluated to true or false — enabling data extraction without visible output or error messages.

This is particularly useful when error-based and union-based techniques are unavailable due to suppressed errors and no direct query output.

---

## Core idea

1. Send a query that executes a time-delay function when a condition is met (e.g., `SLEEP(5)` in MySQL).
2. Measure response time: a significant delay suggests the condition was true.
3. Use this binary signal to extract small pieces of information (characters) iteratively.

Example high-level payload (MySQL-style):

```sql
' OR IF(SUBSTRING((SELECT user()),1,1)='a', SLEEP(5), 0) --
```

If the response is \~5s slower, the first character of `user()` is likely `a`.

---

## DBMS-specific timing functions & examples

**MySQL**

* Function: `SLEEP(seconds)`
* Example:

```sql
' OR IF(SUBSTRING((SELECT database()),1,1)='d', SLEEP(5), 0) --
```

**PostgreSQL**

* Function: `pg_sleep(seconds)`
* Example:

```sql
' OR CASE WHEN SUBSTRING((SELECT current_database()),1,1)='d' THEN pg_sleep(5) ELSE pg_sleep(0) END --
```

**MSSQL (SQL Server)**

* Function: `WAITFOR DELAY 'hh:mm:ss'` (no direct inline sleep in expressions; often needs creative placement)
* Example pattern:

```sql
' IF SUBSTRING((SELECT SYSTEM_USER),1,1)='d' WAITFOR DELAY '00:00:05' --
```

MSSQL sometimes requires different payload placement due to statement structure and API constraints.

**Oracle**

* Function: `DBMS_LOCK.SLEEP(seconds)` (may require specific privileges)
* Example pattern:

```sql
' AND (CASE WHEN SUBSTR((SELECT user FROM dual),1,1) = 'd' THEN DBMS_LOCK.SLEEP(5) ELSE NULL END) IS NULL --
```

Note: Oracle timing functions may be restricted for lower-privileged application accounts.

---

## Practical extraction workflow

1. **Baseline measurement:** Measure average response time for a normal request multiple times to establish variance.
2. **Confirm vulnerability:** Use a simple time test (`SLEEP(5)` unconditional) to see if delays are reflected in responses.
3. **Character extraction:** For position `i` and character candidate `c`, inject a conditional sleep test. Repeat across characters and positions.
4. **Optimize:** Use binary searches over ASCII ranges, and limit character set to speed up extraction.

**Example extraction pseudocode (high-level):**

* For i in 1..N:

  * For each candidate character c in charset:

    * Send payload testing if char i == c with sleep(5).
    * If response delayed, record c and proceed to next i.

---

## Measurement tips and pitfalls

* **Network jitter:** Repeat each test several times and use median or mean to avoid false positives.
* **Application timeouts:** Ensure delays are below server timeout or adapt delay size accordingly.
* **Load balancers & caching:** These can distort timing; test in a stable environment when possible.
* **Request queuing:** High concurrency can change response timings — keep tests low-frequency and controlled.

---

## Defensive guidance

* **Disable or restrict timing functions** (e.g., `SLEEP`, `pg_sleep`, `WAITFOR`) for application DB users where feasible.
* **Apply parameterized queries** to prevent injection in the first place.
* **Rate-limit** endpoints and detect repeated timing-based probes.
* **Monitor for anomalous latencies** correlated with unusual input patterns.
* **Use WAFs** to catch common timing payloads, but do not rely solely on them.

---

## Tooling (authorized use only)

* **Burp Suite**: craft payloads and measure response times with Repeater/Intruder.
* **sqlmap**: supports time-based techniques (`--technique=T`) but is noisy; use only with permission.
* **Custom scripts**: Python + `requests` or `httpx` for controlled timing tests and statistical averaging.

---

## Ethical considerations & scope

> [!TIP]
> * Time-based extraction requires many requests and can cause high load; always respect rules of engagement.
> * Avoid degrading service availability; if load increases unexpectedly, stop testing and notify the owner.