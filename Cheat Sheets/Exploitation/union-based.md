# UNION-based SQL Injection

> [!WARNING]
> **Ethics reminder:** The examples and payloads below are for educational use and authorized testing **only**. Do not attempt these techniques on systems you do not own or do not have explicit written permission to test.

---

## What is UNION-based SQL Injection?

`UNION`-based SQLi allows an attacker to combine the results of a malicious `SELECT` query with the application’s original query result. When successful, the application will display attacker-controlled data (e.g., DB version, usernames) as if it were legitimate query output.

Key requirements:

* The original query and injected `SELECT` must have the **same number of columns**.
* Corresponding columns must have **compatible data types**, or the DBMS will raise an error.
* The injection point must be able to return query output to the attacker (e.g., rendered in an HTML table).

---

## Typical vulnerable pattern

Application builds a query with user input without parameterization:

```sql
SELECT id, name, price FROM products WHERE id = 'USER_INPUT';
```

If `USER_INPUT` is not sanitized, an attacker can attempt to close the string and inject a `UNION SELECT` payload.

---

## Basic payload structure

```sql
' UNION SELECT col1, col2, col3 --
```

* The number of `colN` placeholders must match the number of columns in the original SELECT.
* Use `NULL` or literal values where appropriate to match types.
* `--` (or other comment markers) typically comment out the rest of the original query.

**Example (3-column original):**

```sql
' UNION SELECT NULL, version(), user() --
```

If the application outputs the result set, you may see the database version and current DB user in the rendered page.

---

## Finding the correct column count (safe methods)

1. **Incremental NULL technique:** Try `UNION SELECT NULL` with increasing numbers of NULLs until the DB stops returning a column-count error.

   * `UNION SELECT NULL --` (1 column)
   * `UNION SELECT NULL, NULL --` (2 columns)
   * Continue until there is no error — the count matches.
2. **ORDER BY technique:** Use `ORDER BY` with increasing column indices to find the max columns.

   * `ORDER BY 1 --`, `ORDER BY 2 --`, ... until the DB errors.

**Note:** Always prefer non-destructive tests and keep probes minimal. Many automated tools follow similar approaches but can be noisy.

---

## Matching data types

Once you know the column count, map which columns are displayed and which accept which types:

* Use `NULL` for unknown types.
* Use literal strings (e.g., `'abc'`) for text columns and numeric literals for numeric columns.
* Use functions that return specific types: `version()` (string), `user()` (string), `1` (int).

Example payload to discover display column(s):

```sql
' UNION SELECT 'A', 'B', 'C' --
```

Look for which of `A/B/C` appear in the page output to identify display positions.

---

## DBMS-specific quirks

* **MySQL**: supports `-- ` and `#` comments. Use backticks for identifiers. Functions: `version()`, `user()`, `database()`.
* **Postgres**: uses `--` for comments; string concatenation uses `||`. Functions: `version()`, `current_user`, `current_database()`.
* **MSSQL**: `--` comments, but may require different system functions: `@@version`, `SYSTEM_USER`. Type conversion functions differ (e.g., `CAST()`/`CONVERT()`).
* **Oracle**: `UNION` behavior similar, but functions and quoting vary (e.g., `USER`, `VERSION` pseudo-columns vary by setup).

Always consult DBMS-specific examples in `examples/` for tailored payloads.

---

## Sample exploitation flow (authorized lab only)

1. Confirm injection point with a simple test (`'` or `AND 1=1/1=2`).
2. Determine column count (incremental NULLs or ORDER BY).
3. Probe which columns are reflected in output (inject distinct markers like `'A','B','C'`).
4. Inject a `UNION SELECT` payload with useful functions: `version()`, `user()`, `database()`, `table_name` from `information_schema`.

**Example (MySQL, 3 columns, first column displayed):**

```sql
' UNION SELECT version(), NULL, NULL --
```

If the page shows the DB version in the first output column, you’ve succeeded.

To enumerate tables (careful — noisy):

```sql
' UNION SELECT table_name, NULL, NULL FROM information_schema.tables WHERE table_schema = database() LIMIT 1 OFFSET 0 --
```

Loop over `OFFSET` to enumerate rows.

---

## Detection & defensive tips

* **Use parameterized queries** to eliminate attackers’ ability to inject `UNION` clauses.
* **Limit displayed output** and sanitize any values rendered in templates.
* **Hide database errors** and minimize verbose debugging output in production.
* **Least privilege:** application DB accounts should not have access to `information_schema` unless necessary.
* **WAF rules** can throttle or block common `UNION` payload patterns, but do not rely on them exclusively.

---

## Mitigation checklist (practical)

* Parameterize all queries, do not concatenate user input.
* Validate input types and use whitelist validation for expected values.
* Escape or whitelist column/table names if user input controls them — better: disallow entirely.
* Monitor logs for repeated `UNION` attempts or unusual query shapes.

---

## Notes on responsible testing

> [!NOTE]
> * UNION-based enumeration can be fast and noisy (returns rows). Prefer blind extraction in high-risk contexts or slow, low-frequency enumeration and always stay in-scope.
> * Use lab environments for enumeration tasks. If performing a penetration test, follow the agreed rules of engagement.